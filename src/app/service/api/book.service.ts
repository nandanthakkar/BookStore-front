/**
 * BookStore APIs
 * BookStore APIs exposed from a Java EE back-end to an Angular front-end
 *
 * OpenAPI spec version: 1.0.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { Http, Headers, URLSearchParams }                    from '@angular/http';
import { RequestMethod, RequestOptions, RequestOptionsArgs } from '@angular/http';
import { Response, ResponseContentType }                     from '@angular/http';

import { Observable }                                        from 'rxjs';
import {map} from 'rxjs/operators';

import { Book } from '../model/book';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';

/* tslint:disable:no-unused-variable member-ordering */


@Injectable()
export class BookService {
    protected basePath = 'http://localhost:8080/bookstore-back/api';
    public defaultHeaders: Headers = new Headers({
        'Origin': '*',
        //'Methods': '*',
        //'Access-Control-Request-Methods': 'GET, POST, OPTIONS, PUT, DELETE',
                // 'Access-Control-Allow-Methods': 'GET, POST, OPTIONS, CONNECT, TRACE, PUT, PATCH, DELETE, HEAD',
               'Access-Control-Request-Headers': 'Access-Control-*, Origin, X-Requested-With, Content-Type, Accept',
               'Content-Type' : 'Application/JSON'
              
            });
            // {'Access-Control-Allow-Origin': 'http://localhost:8080'}
    public configuration: Configuration = new Configuration();

    constructor(protected http: Http, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
			this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     *
     * Extends object by coping non-existing properties.
     * @param objA object to be extended
     * @param objB source object
     */
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                (objA as any)[key] = (objB as any)[key];
            }
        }
        return <T1&T2>objA;
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (let consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }

    /**
     * Returns the number of books
     *
     */
    public countBooks(extraHttpRequestParams?: any): Observable<number> {
        return this.countBooksWithHttpInfo(extraHttpRequestParams).pipe(map((response: Response) => {
            if (response.status === 204) {
                return undefined;
            } else {
                return response.json();
            }
        }));
    }

    /**
     * Creates a book given a JSon Book representation
     *
     * @param body Book to be created
     */
    public createBook(body: Book, extraHttpRequestParams?: any): Observable<{}> {
        return this.createBookWithHttpInfo(body, extraHttpRequestParams).pipe(map((response: Response) => {
            switch (response.status) {
                case 204 :
                    return undefined;
                case 201 :
                    return response;
                default :
                    return response.json();
            }
        }));
    }

    /**
     * Deletes a book given an id
     *
     * @param id
     */
    public deleteBook(id: number, extraHttpRequestParams?: any): Observable<{}> {
        return this.deleteBookWithHttpInfo(id, extraHttpRequestParams).pipe(map((response: Response) => {
            if (response.status === 204) {
                return undefined;
            } else {
                return response.json();
            }
        }));
    }

    /**
     * Returns a book given an id
     *
     * @param id
     */
    public getBook(id: number, extraHttpRequestParams?: any): Observable<Book> {
        return this.getBookWithHttpInfo(id, extraHttpRequestParams).pipe(map((response: Response) => {
            if (response.status === 204) {
                return undefined;
            } else {
                return response.json();
            }
        }));
    }

    /**
     * Returns all the books
     *
     */
    public getBooks(extraHttpRequestParams?: any): Observable<Array<Book>> {
        return this.getBooksWithHttpInfo(extraHttpRequestParams).pipe(map((response: Response) => {
            if (response.status === 204) {
                return undefined;
            } else {
                return response.json();
            }
        }));
    }


    /**
     * Returns the number of books
     *
     */
    public countBooksWithHttpInfo(extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/books/count';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845


        // to determine the Accept header
        let produces: string[] = [
            'text/plain'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Creates a book given a JSon Book representation
     *
     * @param body Book to be created
     */
    public createBookWithHttpInfo(body: Book, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/books';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createBook.');
        }

        // to determine the Accept header
        let produces: string[] = [
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Deletes a book given an id
     *
     * @param id
     */
    public deleteBookWithHttpInfo(id: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/books/${id}'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteBook.');
        }

        // to determine the Accept header
        let produces: string[] = [
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Returns a book given an id
     *
     * @param id
     */
    public getBookWithHttpInfo(id: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/books/${id}'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getBook.');
        }

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Returns all the books
     *
     */
    public getBooksWithHttpInfo(extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/books';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

}


// import { Inject, Injectable, Optional }                      from '@angular/core';
// //import { Http }                                              from '@angular/http'; 
// import { HttpClient, HttpClientModule, HttpHeaders, HttpParams,
//          HttpResponse, HttpEvent }                           from '@angular/common/http';
// import { CustomHttpUrlEncodingCodec }                        from '../encoder';

// import { Observable }                                        from 'rxjs';

// import { Book } from '../model/book';

// import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
// import { Configuration }                                     from '../configuration';


// @Injectable()
// export class BookService {

//     protected basePath = 'http://localhost:8080/bookstore-back/api';
//     public defaultHeaders = new HttpHeaders({
//         'Origin': '*',
//         //'Access-Control-Request-Methods': 'GET, POST, OPTIONS, CONNECT, TRACE, PUT, PATCH, DELETE, HEAD',
//         'Access-Control-Request-Headers': 'Access-Control-*, Origin, X-Requested-With, Content-Type, Accept'
//     });
//     public configuration = new Configuration();
    
//     constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
//         if (basePath) {
//             this.basePath = basePath;
//         }
//         if (configuration) {
//             this.configuration = configuration;
//             this.basePath = basePath || configuration.basePath || this.basePath;
//         }
//     }

//     /**
//      * @param consumes string[] mime-types
//      * @return true: consumes contains 'multipart/form-data', false: otherwise
//      */
//     private canConsumeForm(consumes: string[]): boolean {
//         const form = 'multipart/form-data';
//         for (let consume of consumes) {
//             if (form === consume) {
//                 return true;
//             }
//         }
//         return false;
//     }


//     /**
//      * Return number of books
//      * 
//      * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
//      * @param reportProgress flag to report request and response progress.
//      */
//     public countBooks(observe?: 'body', reportProgress?: boolean): Observable<number>;
//     public countBooks(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<number>>;
//     public countBooks(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<number>>;
//     public countBooks(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

//         let headers = this.defaultHeaders;

//         // to determine the Accept header
//         let httpHeaderAccepts: string[] = [
//         ];
//         let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
//         if (httpHeaderAcceptSelected != undefined) {
//             headers = headers.set("Accept", httpHeaderAcceptSelected);
//         }

//         // to determine the Content-Type header
//         let consumes: string[] = [
//         ];

//         return this.httpClient.get<number>(`${this.basePath}/books/count`,
//             {
//                 withCredentials: this.configuration.withCredentials,
//                 headers: headers,
//                 observe: observe,
//                 reportProgress: reportProgress
//             }
//         );
//     }

//     /**
//      * Create book given a JSON represenation
//      * 
//      * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
//      * @param reportProgress flag to report request and response progress.
//      */
//     public createBook(observe?: 'body', reportProgress?: boolean): Observable<Book>;
//     public createBook(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Book>>;
//     public createBook(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Book>>;
//     public createBook(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

//         let headers = this.defaultHeaders;

//         // to determine the Accept header
//         let httpHeaderAccepts: string[] = [
//         ];
//         let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
//         if (httpHeaderAcceptSelected != undefined) {
//             headers = headers.set("Accept", httpHeaderAcceptSelected);
//         }

//         // to determine the Content-Type header
//         let consumes: string[] = [
//             'application/json'
//         ];

//         return this.httpClient.post<Book>(`${this.basePath}/books`,
//             null,
//             {
//                 withCredentials: this.configuration.withCredentials,
//                 headers: headers,
//                 observe: observe,
//                 reportProgress: reportProgress
//             }
//         );
//     }

//     /**
//      * Delete book given its ID
//      * 
//      * @param id 
//      * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
//      * @param reportProgress flag to report request and response progress.
//      */
//     public deleteBook(id: number, observe?: 'body', reportProgress?: boolean): Observable<Book>;
//     public deleteBook(id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Book>>;
//     public deleteBook(id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Book>>;
//     public deleteBook(id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
//         if (id === null || id === undefined) {
//             console.error('Required parameter id was null or undefined when calling deleteBook.');
//             throw new Error('Required parameter id was null or undefined when calling deleteBook.');
//         }

//         let headers = this.defaultHeaders;

//         // to determine the Accept header
//         const httpHeaderAccepts: string[] = [
//         ];
//         const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
//         if (httpHeaderAcceptSelected !== undefined) {
//             headers = headers.set('Accept', httpHeaderAcceptSelected);
//         }

//         // to determine the Content-Type header
//         const consumes: string[] = [
//         ];

//         return this.httpClient.delete<Book>(`${this.basePath}/books/${encodeURIComponent(String(id))}`,
//             {
//                 withCredentials: this.configuration.withCredentials,
//                 headers: headers,
//                 observe: observe,
//                 reportProgress: reportProgress
//             }
//         );
//     }

//     /**
//      * return a book given an identifier
//      * 
//      * @param id 
//      * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
//      * @param reportProgress flag to report request and response progress.
//      */
//     public getBook(id: number, observe?: 'body', reportProgress?: boolean): Observable<Book>;
//     public getBook(id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Book>>;
//     public getBook(id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Book>>;
//     public getBook(id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
//         if (id === null || id === undefined) {
//             throw new Error('Required parameter id was null or undefined when calling getBook.');
//         }

//         let headers = this.defaultHeaders;

//         // to determine the Accept header
//         const httpHeaderAccepts: string[] = [
//             'application/json'
//         ];
//         const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
//         if (httpHeaderAcceptSelected != undefined) {
//             headers = headers.set("Accept", httpHeaderAcceptSelected);
//         }

//         // to determine the Content-Type header
//         const consumes: string[] = [
//         ];

//         return this.httpClient.get<Book>(`${this.basePath}/books/${encodeURIComponent(String(id))}`,
//             {
//                 withCredentials: this.configuration.withCredentials,
//                 headers: headers,
//                 observe: observe,
//                 reportProgress: reportProgress
//             }
//         );
//     }

//     /**
//      * Return all the books
//      * 
//      * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
//      * @param reportProgress flag to report request and response progress.
//      */
//     public getBooks(observe?: 'body', reportProgress?: boolean): Observable<any>;
//     public getBooks(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
//     public getBooks(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
//     public getBooks(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

//         let headers = this.defaultHeaders;

//         // to determine the Accept header
//         let httpHeaderAccepts: string[] = [
//             'application/json'
//         ];
//         let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
//         if (httpHeaderAcceptSelected != undefined) {
//             headers = headers.set("Accept", httpHeaderAcceptSelected);
//         }

//         // to determine the Content-Type header
//         let consumes: string[] = [
//         ];

//         return this.httpClient.get<any>(`${this.basePath}/books`,
//             {
//                 withCredentials: this.configuration.withCredentials,
//                 headers: headers,
//                 observe: observe,
//                 reportProgress: reportProgress
//             }
//         );
//     }

// }
